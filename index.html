<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Ringe – Final (Vollbild, Optionen davor)</title>
<style>
  :root{
    --bg:#0b0f15; --bg2:#06080d; --fg:#e9eef6; --accent:#a9b8ff;
    --glass: rgba(10,13,20,.5); --line: rgba(255,255,255,.08);
  }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
  #wrap { position:relative; width:100%; height:100%; overflow:hidden; }

  /* Zwei Layer: main unten (Hintergrund, Ringe, Ball), paint oben (permanente Trails) */
  canvas { position:absolute; inset:0; width:100%; height:100%; touch-action:none; }
  #c { z-index: 1; }           /* Spiel */
  #paintCanvas { z-index: 2; pointer-events:none; } /* Zeichnen oben drüber */

  /* HUD */
  .hud {
    position:absolute; left:12px; top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:var(--glass); border:1px solid var(--line); border-radius:10px; padding:8px 10px; backdrop-filter: blur(8px);
    font-size:13px; z-index:3;
  }
  .hud .stat { padding:4px 8px; border-radius:8px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); }
  .hud button {
    appearance:none; border:1px solid rgba(255,255,255,.2); background:#121823; color:var(--fg); padding:6px 10px; border-radius:8px; cursor:pointer; font-size:13px;
  }
  .hud button:hover { filter:brightness(1.1); }

  .msg {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    background:rgba(10,13,20,.65); border:1px solid var(--line); padding:14px 18px; border-radius:12px;
    font-weight:600; letter-spacing:.3px; display:none; z-index:3;
  }
  .kbd{ font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#131a27; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.12); font-size:12px }

  /* Start-/Options-Screen */
  #startScreen{
    position:fixed; inset:0; background:linear-gradient(160deg, #0b0f15 0%, #06080d 100%);
    display:flex; align-items:center; justify-content:center; padding:16px;
    z-index:10;
  }
  .panel{
    width:min(520px, 96vw); max-height:92vh; overflow:auto;
    background:var(--glass); border:1px solid var(--line); border-radius:16px; padding:16px 18px; backdrop-filter: blur(10px);
    box-shadow: 0 20px 40px rgba(0,0,0,.45);
  }
  .panel h1{ margin:.2rem 0 .6rem; font-size:20px; letter-spacing:.4px; }
  .rows{ display:flex; flex-direction:column; gap:10px; }
  .row{ display:flex; flex-direction:column; gap:6px; }
  .row label{ font-size:13px; opacity:.95 }
  .row input[type="range"], .row select{ width:100%; }
  .row input, .row select{
    background:#121823; color:var(--fg); border:1px solid rgba(255,255,255,.18); border-radius:8px; padding:8px 10px; font-size:14px;
  }
  .hint{ font-size:12px; opacity:.85; margin-top:8px }
  .actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }
  .actions button{
    background:#1f3a8a; border:1px solid #2a4cc1; color:var(--fg); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;
  }
  .actions button:hover{ filter:brightness(1.05); }

  .hidden{ display:none !important; }
</style>
</head>
<body>
<!-- präzise mm-Kalibrierung -->
<div id="mmCal" style="position:absolute; visibility:hidden; width:10mm; height:1px;"></div>

<div id="wrap">
  <!-- Paint-Layer (dauerhafte Zeichnung, liegt OBEN) -->
  <canvas id="paintCanvas"></canvas>
  <!-- Main-Layer (Hintergrund, Ringe, Ball) -->
  <canvas id="c"></canvas>

  <!-- HUD -->
  <div class="hud hidden" id="hud">
    <span class="stat">Layers: <b id="layersLeft">10</b></span>
    <span class="stat">Bounces: <b id="bounces">0</b></span>
    <button id="backMenu">Zurück ins Menü</button>
    <button id="reset">Neu starten</button>
  </div>

  <div id="msg" class="msg">Alle Layers entfernt! Tippe/Klick in die Mitte und schieße erneut.</div>
</div>

<!-- Start-/Optionen-Bildschirm -->
<div id="startScreen">
  <div class="panel">
    <h1>⚙️ Optionen</h1>
    <div class="rows">
      <div class="row">
        <label for="shape">Form</label>
        <select id="shape">
          <option value="circle">Kreis</option>
          <option value="triangle">Dreieck</option>
          <option value="square">Quadrat</option>
        </select>
      </div>

      <div class="row">
        <label for="numRings">Anzahl Ringe: <span id="numRingsVal" class="kbd">10</span></label>
        <input id="numRings" type="range" min="3" max="30" value="10"/>
      </div>

      <div class="row">
        <label id="openWidthLbl" for="openWidth">Öffnung (°): <span id="openWidthVal" class="kbd">40°</span></label>
        <!-- Kreis: Grad, Dreieck/Quadrat: Millimeter (am Bildschirm gemessen, mm-genau kalibriert) -->
        <input id="openWidth" type="range" min="15" max="120" value="40"/>
      </div>

      <div class="row">
        <label for="shotSpeed">Max. Schusskraft: <span id="shotSpeedVal" class="kbd">1100</span></label>
        <input id="shotSpeed" type="range" min="300" max="1800" value="1100"/>
      </div>

      <div class="row">
        <label for="gravity">Gravitation: <span id="gravityVal" class="kbd">1300</span></label>
        <input id="gravity" type="range" min="400" max="2200" value="1300"/>
      </div>

      <div class="row">
        <label for="trailLen">Spurlänge (Normalmodus): <span id="trailLenVal" class="kbd">70</span></label>
        <input id="trailLen" type="range" min="10" max="1000" value="70"/>
      </div>

      <div class="row">
        <label><input id="multi" type="checkbox"/> Multiball</label>
      </div>

      <div class="row">
        <label><input id="drawMode" type="checkbox"/> Zeichenmodus (permanenter Regenbogen-Schweif)</label>
      </div>

      <!-- NEU: Audio-Optionen -->
      <div class="row">
        <label for="pitchShift">Tonleiter – Pitch (±5 Halbtöne): <span id="pitchShiftVal" class="kbd">0</span></label>
        <input id="pitchShift" type="range" min="-5" max="5" step="1" value="0"/>
      </div>

      <div class="row">
        <label for="toneDur">Ton-Dauer (bis 5 s): <span id="toneDurVal" class="kbd">0.22 s</span></label>
        <input id="toneDur" type="range" min="0.22" max="5" step="0.01" value="0.22"/>
      </div>

      <div class="row">
        <label for="toneOrder">Reihenfolge Tonfolge</label>
        <select id="toneOrder">
          <option value="updown">aufsteigend–absteigend</option>
          <option value="downup">absteigend–aufsteigend</option>
          <option value="random">zufällig</option>
        </select>
      </div>

      <div class="row">
        <label for="toneType">Ton-Art</label>
        <select id="toneType">
          <option value="sine">Sine (sauber)</option>
          <option value="square">Square</option>
          <option value="sawtooth">Saw</option>
          <option value="triangle">Triangle</option>
          <option value="horn">Hupe</option>
          <option value="fart">Pupsen</option>
          <option value="pluck">Pluck (Saiten-ähnlich)</option>
          <option value="noise">Rauschen</option>
        </select>
      </div>

      <div class="row">
        <label><input id="autoRestart" type="checkbox"/> Auto-Neustart nach letzter Schicht (statt Text)</label>
      </div>
    </div>

    <div class="hint">
      <span class="kbd">Ziehen &amp; Loslassen</span> zum Schießen •
      <span class="kbd">Tap/Klick</span> nahe Zentrum: Ball-Reset •
      <span class="kbd">Neu starten</span> setzt Level neu
    </div>

    <div class="actions">
      <button id="startBtn" class="primary">START (Vollbild)</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ========= Canvas & Globals =========
  const main = document.getElementById('c');
  const paint = document.getElementById('paintCanvas');
  const ctx = main.getContext('2d');
  const ptx = paint.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  let W=0,H=0,CX=0,CY=0;
  let pxPerMM=3.78*dpr; // Fallback, wird kalibriert

  // Screens / HUD
  const startScreen = document.getElementById('startScreen');
  const hud = document.getElementById('hud');
  const elLayers = document.getElementById('layersLeft');
  const elBounces= document.getElementById('bounces');
  const btnReset = document.getElementById('reset');
  const btnBack  = document.getElementById('backMenu');
  const elMsg    = document.getElementById('msg');

  // Options UI
  const ui = {
    shape: document.getElementById('shape'),
    numRings: document.getElementById('numRings'),
    numRingsVal: document.getElementById('numRingsVal'),
    openWidthLbl: document.getElementById('openWidthLbl'),
    openWidth: document.getElementById('openWidth'),
    openWidthVal: document.getElementById('openWidthVal'),
    shotSpeed: document.getElementById('shotSpeed'),
    shotSpeedVal: document.getElementById('shotSpeedVal'),
    gravity: document.getElementById('gravity'),
    gravityVal: document.getElementById('gravityVal'),
    trailLen: document.getElementById('trailLen'),
    trailLenVal: document.getElementById('trailLenVal'),
    multi: document.getElementById('multi'),
    drawMode: document.getElementById('drawMode'),
    // Audio neu:
    pitchShift: document.getElementById('pitchShift'),
    pitchShiftVal: document.getElementById('pitchShiftVal'),
    toneDur: document.getElementById('toneDur'),
    toneDurVal: document.getElementById('toneDurVal'),
    toneOrder: document.getElementById('toneOrder'),
    toneType: document.getElementById('toneType'),
    autoRestart: document.getElementById('autoRestart'),
    startBtn: document.getElementById('startBtn')
  };

  function updateOpenUnitLabel(){
    const isPoly = ui.shape.value !== 'circle';
    ui.openWidthLbl.firstChild.textContent = isPoly ? "Öffnung (mm): " : "Öffnung (°): ";
    ui.openWidthVal.textContent = ui.openWidth.value + (isPoly ? " mm" : "°");
  }
  function syncLabels(){
    ui.numRingsVal.textContent = ui.numRings.value;
    ui.shotSpeedVal.textContent = ui.shotSpeed.value;
    ui.gravityVal.textContent = ui.gravity.value;
    ui.trailLenVal.textContent = ui.trailLen.value;
    ui.pitchShiftVal.textContent = ui.pitchShift.value;
    ui.toneDurVal.textContent = parseFloat(ui.toneDur.value).toFixed(2) + " s";
    updateOpenUnitLabel();
  }
  [ui.numRings, ui.openWidth, ui.shotSpeed, ui.gravity, ui.trailLen, ui.pitchShift, ui.toneDur, ui.shape].forEach(el=>{
    el.addEventListener('input', syncLabels);
    el.addEventListener('change', syncLabels);
  });
  syncLabels();

  // ========= Audio =========
  let audioCtx=null, masterGain=null, bounceCount=0;
  const scaleSemitones=[0,3,5,7,10,12,15,17]; // 8 Töne
  const seqState = { idx:0, dir:1 };
  function resetToneSeq(){
    const N=scaleSemitones.length;
    if (ui.toneOrder.value==='downup'){ seqState.idx=N-1; seqState.dir=-1; }
    else { seqState.idx=0; seqState.dir=1; }
  }
  function nextScaleIndex(){
    const N=scaleSemitones.length;
    const mode = ui.toneOrder.value;
    if (mode==='random') return Math.floor(Math.random()*N);
    const out = seqState.idx;
    seqState.idx += seqState.dir;
    if (seqState.idx>=N-1 || seqState.idx<=0) seqState.dir *= -1; // Ping-Pong
    return out;
  }

  function initAudio(){
    if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      masterGain=audioCtx.createGain(); masterGain.gain.value=0.18; masterGain.connect(audioCtx.destination);
    }
    if(audioCtx.state==='suspended') audioCtx.resume();
  }

  function playBounce(){
    if(!audioCtx) return;
    const t=audioCtx.currentTime;

    // Pitch-Shift in Halbtönen (-5..+5)
    const shift = parseInt(ui.pitchShift.value,10) || 0;

    const idx = nextScaleIndex();
    const octave = (Math.floor(bounceCount/scaleSemitones.length))%2;
    const semi   = scaleSemitones[idx] + 12*octave + shift;
    const freq   = 220*Math.pow(2, semi/12);
    const dur = Math.max(0.22, Math.min(5, parseFloat(ui.toneDur.value)||0.22));

    const type = ui.toneType.value;

    // Ton-Engines
    if (type==='noise'){
      const len = Math.max(0.05, Math.min(5, dur));
      const sr  = audioCtx.sampleRate;
      const buffer = audioCtx.createBuffer(1, Math.floor(sr*len), sr);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
      const src = audioCtx.createBufferSource(); src.buffer = buffer;
      const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq; bp.Q.value=2.5;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.001, t);
      g.gain.exponentialRampToValueAtTime(0.4, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0008, t+len);
      src.connect(bp); bp.connect(g); g.connect(masterGain);
      src.start(t); src.stop(t+len);
    } else if (type==='horn'){
      const osc=audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.setValueAtTime(freq,t);
      const lfo=audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=6; // Vibrato
      const lfoGain=audioCtx.createGain(); lfoGain.gain.value=8; // ±8 Hz
      const g=audioCtx.createGain();
      g.gain.setValueAtTime(0.001,t);
      g.gain.exponentialRampToValueAtTime(0.5,t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0008, t+dur);
      lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
      osc.connect(g); g.connect(masterGain);
      osc.start(t); lfo.start(t); osc.stop(t+dur+0.02); lfo.stop(t+dur+0.02);
    } else if (type==='fart'){
      const osc=audioCtx.createOscillator(); osc.type='square';
      const f0 = Math.max(40, Math.min(160, freq*0.35));
      osc.frequency.setValueAtTime(f0, t);
      osc.frequency.exponentialRampToValueAtTime(40, t+dur*0.8);
      const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=280;
      const g=audioCtx.createGain();
      g.gain.setValueAtTime(0.001,t);
      g.gain.exponentialRampToValueAtTime(0.6,t+0.015);
      g.gain.exponentialRampToValueAtTime(0.0008,t+dur);
      osc.connect(lp); lp.connect(g); g.connect(masterGain);
      osc.start(t); osc.stop(t+dur+0.02);
    } else if (type==='pluck'){
      // Rauschen + Bandpass mit schnellem Decay (simple Karplus-Strong-Anmutung)
      const len = Math.max(0.1, Math.min(3, dur));
      const sr  = audioCtx.sampleRate;
      const buffer = audioCtx.createBuffer(1, Math.floor(sr*len), sr);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
      const src = audioCtx.createBufferSource(); src.buffer = buffer; src.loop=false;
      const bp  = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq*2; bp.Q.value=8;
      const g=audioCtx.createGain();
      g.gain.setValueAtTime(0.001,t);
      g.gain.exponentialRampToValueAtTime(0.7,t+0.003);
      g.gain.exponentialRampToValueAtTime(0.0006,t+len);
      src.connect(bp); bp.connect(g); g.connect(masterGain);
      src.start(t); src.stop(t+len);
    } else {
      // Standard-Oszillatoren
      const osc=audioCtx.createOscillator();
      osc.type = type; // sine/square/sawtooth/triangle
      osc.frequency.setValueAtTime(freq,t);
      const g=audioCtx.createGain();
      g.gain.setValueAtTime(0.001,t);
      g.gain.exponentialRampToValueAtTime(0.35,t+0.012);
      g.gain.exponentialRampToValueAtTime(0.0008,t+dur);
      osc.connect(g); g.connect(masterGain);
      osc.start(t); osc.stop(t+dur+0.02);
    }

    bounceCount++; elBounces.textContent=bounceCount;
  }

  // ========= Math/Utils =========
  function angleNorm(a){ a%=Math.PI*2; return a<0?a+Math.PI*2:a; }
  function angleDiff(a,b){ let d=angleNorm(a)-angleNorm(b); d=(d+Math.PI)%(Math.PI*2)-Math.PI; return Math.abs(d); }
  function inOpening(theta, center, width){ return angleDiff(theta, center)<= (width*0.5); }

  function radialToRegularPolygon(theta, R, n, rot){
    if (n<=0) return R; // circle fallback
    const a = ((theta - rot)%(Math.PI*2)+Math.PI*2)%(Math.PI*2);
    const sector = Math.PI*2/n;
    const half = sector*0.5;
    const denom = Math.cos((a%sector)-half);
    const c = Math.cos(half);
    return R * c / Math.max(0.0001, denom);
  }
  function polygonEdgeNormalAngle(theta, n, rot){
    if (n<=0) return theta; // circle radial normal
    const sector = Math.PI*2/n;
    const a = ((theta - rot)%(Math.PI*2)+Math.PI*2)%(Math.PI*2);
    const k = Math.floor(a/sector);
    return rot + k*sector; // outward normal angle
  }
  function reflectVelocity(vx, vy, nx, ny){
    const dot = vx*nx + vy*ny;
    return { vx: vx - 2*dot*nx, vy: vy - 2*dot*ny };
  }

  // ========= Game State =========
  const BASE_ROT_SPEED=0.9, MAX_SUBSTEPS=16, SUBSTEP_PIXELS=0.7, MAX_BALLS=200;
  let rings=[]; // ordered inner -> outer
  let ringsLeft=0;
  let NUM_RINGS=10, OPEN_WIDTH_VAL=40, MAX_SHOT=1100, G=1300;
  let TRAIL_MAX=70;
  let ballRadius=6;
  let launched=false, aiming=true, aimX=0, aimY=0, finished=false;

  // Balls with per-ball current ring index + hue for draw mode
  const balls=[];
  function makeBall(x,y,vx=0,vy=0){
    return { x, y, px:x, py:y, vx, vy, r:ballRadius, trail:[], ringIndex:0, hue:Math.random()*360 };
  }

  // ========= Layout / Zoom =========
  function calibrateMM(){
    const mmDiv = document.getElementById('mmCal');
    const wCss = mmDiv.getBoundingClientRect().width; // CSS-px für 10 mm
    if (wCss>0) pxPerMM = (wCss/10) * dpr; // Canvas-px pro mm
  }
  function resize(){
    const rect = main.getBoundingClientRect();
    const w = Math.floor(rect.width*dpr), h = Math.floor(rect.height*dpr);
    if (w===W && h===H) return;
    W = w; H = h;
    main.width=W; main.height=H;
    paint.width=W; paint.height=H;
    CX=W/2; CY=H/2;
    calibrateMM();
  }
  window.addEventListener('resize', resize, {passive:true});

  function computeLevel(){
    // read UI
    NUM_RINGS=+ui.numRings.value;
    OPEN_WIDTH_VAL=+ui.openWidth.value; // Kreis: Grad, Polygon: Millimeter
    MAX_SHOT=+ui.shotSpeed.value; G=+ui.gravity.value; TRAIL_MAX=+ui.trailLen.value;

    finished=false;
    resetToneSeq();

    // --- Auto-zoom: Außenring garantiert sichtbar, konstanter Randabstand ---
    const edgeGap = Math.max(22*dpr, 16);                 // fixer Abstand zum Displayrand
    const Ravail = Math.min(W,H)/2 - edgeGap;             // max. Außenradius
    const gapRatio = 0.33;
    const spanFactor = (NUM_RINGS + (NUM_RINGS-1)*gapRatio);

    let innerStart = 28*dpr;
    let thickness = (Ravail - innerStart) / spanFactor;

    if (!isFinite(thickness) || thickness <= 0){
      thickness = Math.max(1.5*dpr, Ravail / Math.max(1, spanFactor+1));
      innerStart = Math.max(8*dpr, Ravail - thickness*spanFactor);
    } else if (thickness < 1.5*dpr){
      thickness = Math.max(1.5*dpr, (Ravail - 8*dpr)/spanFactor);
      innerStart = Math.max(8*dpr, Ravail - thickness*spanFactor);
    }

    const gap = thickness * gapRatio;

    // build rings
    rings.length=0;
    const shape = ui.shape.value; // 'circle' | 'triangle' | 'square'
    let nSides = 0;
    if (shape==='triangle') nSides=3;
    else if (shape==='square') nSides=4;

    // Polygone: gleiche Rotationsgeschwindigkeit & Orientierung für alle Schichten
    let sharedRotSpeed = 0;
    let sharedPolyRot0 = 0;
    if (nSides>0){
      const signDir = Math.random()<0.5?-1:1;
      const factor = 0.75 + Math.random()*0.5; // 0.75..1.25
      sharedRotSpeed = signDir * BASE_ROT_SPEED * factor;
      sharedPolyRot0 = Math.random()*Math.PI*2;
    }

    for (let i=0;i<NUM_RINGS;i++){
      const innerCirc = innerStart + i*(thickness+gap);
      const outerCirc = innerCirc + thickness;
      const midCirc   = (innerCirc + outerCirc)*0.5;

      let openCenter = Math.random()*Math.PI*2;
      let openWidthAngle;

      if (nSides===0){
        // Kreis: Öffnungswinkel in Grad
        openWidthAngle = OPEN_WIDTH_VAL * Math.PI/180;
        const signDir = Math.random()<0.5?-1:1;
        const factor = 0.5 + Math.random(); // 0.5..1.5
        const rotSpeed = signDir * BASE_ROT_SPEED * factor;
        const polyRot = Math.random()*Math.PI*2;
        rings.push({ shape, nSides, innerCirc, outerCirc, midCirc, openCenter, openWidthAngle, rotSpeed, polyRot, removed:false });
      } else {
        // Dreieck/Quadrat: Öffnung in Millimeter (am Bildschirm), in Winkel konvertieren
        const arcLenPx = OPEN_WIDTH_VAL * pxPerMM;
        openWidthAngle = Math.max(arcLenPx / Math.max(1, midCirc), 0.02); // Mindestbreite
        rings.push({
          shape, nSides, innerCirc, outerCirc, midCirc,
          openCenter, openWidthAngle,
          rotSpeed: sharedRotSpeed,
          polyRot: sharedPolyRot0,
          removed:false
        });
      }
    }

    ballRadius = Math.max(5*dpr, thickness * 0.23);
    resetRunState();
    elMsg.style.display='none';
    ringsLeft = rings.length;
    elLayers.textContent = String(ringsLeft);
    bounceCount = 0; elBounces.textContent = "0";
  }

  function resetRunState(){
    // clear paint layer (nur bei Level-Neustart)
    ptx.clearRect(0,0,W,H);
    ptx.lineCap='round'; ptx.lineJoin='round'; // schöne Linien
    ptx.globalAlpha = 0.95;

    balls.length=0;
    // fixierter Spawn Offset = 20px nach unten
    const spawnX = CX;
    const spawnY = CY + 20*dpr;
    const b = makeBall(spawnX, spawnY, 0, 0);
    b.trail.push({x:b.x,y:b.y});
    balls.push(b);
    aiming=true; launched=false; finished=false; elMsg.style.display='none';
  }

  function resetToMenuState(){
    // Alles stoppen/aufräumen (nichts läuft im Hintergrund weiter)
    launched=false; aiming=false; finished=false;
    rings.length=0; balls.length=0;
    ctx.clearRect(0,0,W,H); ptx.clearRect(0,0,W,H);
    elMsg.style.display='none';
    bounceCount=0; elBounces.textContent='0'; elLayers.textContent='0';
    try { if (audioCtx && audioCtx.state!=='closed') audioCtx.suspend(); } catch(e){}
  }

  // ========= Input =========
  function getPos(e){
    const rect=main.getBoundingClientRect();
    if (e.touches && e.touches.length){
      return { x:(e.touches[0].clientX-rect.left)*dpr, y:(e.touches[0].clientY-rect.top)*dpr };
    }
    return { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
  }
  function pointerDown(e){
    initAudio();
    const p=getPos(e);
    if (!launched){
      aiming=true; aimX=p.x; aimY=p.y;
    } else {
      // Klick nahe Zentrum = Reset Run
      const dx=p.x-CX, dy=p.y-CY;
      if (Math.hypot(dx,dy)<Math.min(W,H)*0.08) resetRunState();
    }
  }
  function pointerMove(e){
    if(!aiming) return;
    const p=getPos(e); aimX=p.x; aimY=p.y;
  }
  function pointerUp(){
    if (!aiming) return;
    const ax=aimX-CX, ay=aimY-CY;
    const len=Math.hypot(ax,ay);
    if (len>0.0001){
      const maxPull=Math.min(W,H)*0.46*0.55;
      const pull=Math.min(len, maxPull);
      const dirx=ax/len, diry=ay/len;
      const v= MAX_SHOT * (pull/maxPull*0.75 + 0.25);
      for (const b of balls){ b.vx=dirx*v; b.vy=diry*v; }
      launched=true; aiming=false;
      initAudio();
    }
  }
  main.addEventListener('mousedown', pointerDown);
  main.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);
  main.addEventListener('touchstart', (e)=>{ pointerDown(e); }, {passive:true});
  main.addEventListener('touchmove',  (e)=>{ pointerMove(e); },  {passive:true});
  main.addEventListener('touchend',   (e)=>{ pointerUp(); },     {passive:true});

  btnReset.addEventListener('click', ()=>{ computeLevel(); });

  // ========= Physics: Kollision identisch zum Kreis-Material (auch bei Polygonen) =========
  function reflectRadial(b){
    const r = Math.hypot(b.x-CX, b.y-CY); if (r===0) return;
    const nx=(b.x-CX)/r, ny=(b.y-CY)/r;
    const rv = reflectVelocity(b.vx,b.vy,nx,ny); b.vx=rv.vx; b.vy=rv.vy;
  }
  function reflectPolygon(b, theta, nSides, rot){
    if (nSides<=0){ reflectRadial(b); return; }
    const nAng = polygonEdgeNormalAngle(theta, nSides, rot);
    const nx=Math.cos(nAng), ny=Math.sin(nAng);
    const rv = reflectVelocity(b.vx,b.vy,nx,ny); b.vx=rv.vx; b.vy=rv.vy;
  }

  function processRingForBall(b, ring){
    if (finished) return;
    const rNow = Math.hypot(b.x-CX, b.y-CY);
    const rPrev= Math.hypot(b.px-CX, b.py-CY);
    const thNow= angleNorm(Math.atan2(b.y-CY, b.x-CX));

    // Grenzen (Material wie beim Kreis – aber Radien folgen Polygongeometrie)
    let innerB, outerB;
    if (ring.nSides>0){
      innerB = radialToRegularPolygon(thNow, ring.innerCirc, ring.nSides, ring.polyRot) + b.r;
      outerB = radialToRegularPolygon(thNow, ring.outerCirc, ring.nSides, ring.polyRot) - b.r;
    } else {
      innerB = ring.innerCirc + b.r;
      outerB = ring.outerCirc - b.r;
    }

    const open = inOpening(thNow, ring.openCenter, ring.openWidthAngle);

    // Inner Crossing
    if (rPrev < innerB && rNow >= innerB){
      if (!open){
        const ux=(b.x-CX)/(rNow||1), uy=(b.y-CY)/(rNow||1);
        const snap = (innerB - 0.01);
        b.x = CX + ux*snap; b.y = CY + uy*snap;
        if (ring.nSides>0) reflectPolygon(b, thNow, ring.nSides, ring.polyRot); else reflectRadial(b);
        playBounce();
      }
    } else if (rPrev > innerB && rNow <= innerB){
      if (!open){
        const ux=(b.x-CX)/(rNow||1), uy=(b.y-CY)/(rNow||1);
        const snap = (innerB + 0.01);
        b.x = CX + ux*snap; b.y = CY + uy*snap;
        if (ring.nSides>0) reflectPolygon(b, thNow, ring.nSides, ring.polyRot); else reflectRadial(b);
        playBounce();
      }
    }

    // Outer Crossing
    if (rPrev < outerB && rNow >= outerB){
      if (open){
        // Verlassen: Ring entfernen, ringIndex erhöhen, Multiball hier
        if (!ring.removed){
          ring.removed = true;
          ringsLeft = rings.filter(r=>!r.removed).length;
          elLayers.textContent = String(ringsLeft);
          if (ringsLeft===0){
            if (ui.autoRestart.checked){
              computeLevel();
              return;
            } else {
              // Freeze statt weiterhüpfen
              launched=false; aiming=false; finished=true;
              elMsg.style.display='block';
            }
          }
        }
        b.ringIndex++;
        if (ui.multi.checked && balls.length < MAX_BALLS){
          const speed = Math.hypot(b.vx,b.vy);
          const ang   = Math.atan2(b.vy,b.vx);
          const delta = 0.18;
          const nb = makeBall(b.x, b.y, Math.cos(ang+delta)*speed, Math.sin(ang+delta)*speed);
          nb.ringIndex = b.ringIndex;
          balls.push(nb);
          b.vx = Math.cos(ang-delta)*speed; b.vy = Math.sin(ang-delta)*speed;
        }
      } else {
        const ux=(b.x-CX)/(rNow||1), uy=(b.y-CY)/(rNow||1);
        const snap = (outerB - 0.01);
        b.x = CX + ux*snap; b.y = CY + uy*snap;
        if (ring.nSides>0) reflectPolygon(b, thNow, ring.nSides, ring.polyRot); else reflectRadial(b);
        playBounce();
      }
    } else if (rPrev > outerB && rNow <= outerB){
      if (!open){
        const ux=(b.x-CX)/(rNow||1), uy=(b.y-CY)/(rNow||1);
        const snap = (outerB + 0.01);
        b.x = CX + ux*snap; b.y = CY + uy*snap;
        if (ring.nSides>0) reflectPolygon(b, thNow, ring.nSides, ring.polyRot); else reflectRadial(b);
        playBounce();
      }
    }
  }

  // ========= Loop =========
  let lastT=0;
  function step(ts){
    const t=ts/1000;
    const dtFull=Math.min(0.033, t-lastT || 0.016);
    lastT=t;

    // Rotate rings
    for (const ring of rings){
      if (ring.removed) continue;
      // Öffnung & Orientierung drehen
      ring.openCenter = angleNorm(ring.openCenter + ring.rotSpeed*dtFull);
      ring.polyRot    = angleNorm(ring.polyRot    + (ring.nSides>0 ? ring.rotSpeed : ring.rotSpeed*0.5)*dtFull);
    }

    // Physics
    if (launched){
      // Substeps
      let maxSpeed=0;
      for (const b of balls) maxSpeed=Math.max(maxSpeed, Math.hypot(b.vx,b.vy));
      const desiredSteps=Math.ceil((maxSpeed*dtFull)/SUBSTEP_PIXELS);
      const steps=Math.max(1, Math.min(MAX_SUBSTEPS, desiredSteps));
      const dt=dtFull/steps;

      for (let s=0;s<steps;s++){
        for (const b of balls){
          b.px=b.x; b.py=b.y;

          // gravity
          b.vy += G*dt;

          // move
          b.x += b.vx*dt;
          b.y += b.vy*dt;

          // Kollision NUR mit aktueller Schicht
          let idx = b.ringIndex;
          while (idx < rings.length && rings[idx].removed) idx++;
          b.ringIndex = idx;
          if (idx < rings.length){
            processRingForBall(b, rings[idx]);
          }

          // Wände
          const margin = b.r + 4*dpr;
          if (b.x < margin){ b.x = margin; b.vx = Math.abs(b.vx); playBounce(); }
          if (b.x > W - margin){ b.x = W - margin; b.vx = -Math.abs(b.vx); playBounce(); }
          if (b.y < margin){ b.y = margin; b.vy = Math.abs(b.vy); playBounce(); }
          if (b.y > H - margin){ b.y = H - margin; b.vy = -Math.abs(b.vy); playBounce(); }

          // Trails
          b.trail.push({x:b.x,y:b.y});
          if (!ui.drawMode.checked && b.trail.length>TRAIL_MAX) b.trail.shift();

          // Zeichenmodus: permanent auf paint-Canvas malen (Regenbogen, langsamer Wechsel)
          if (ui.drawMode.checked){
            b.hue = (b.hue + 30*dt) % 360;
            ptx.strokeStyle = `hsl(${b.hue}, 80%, 60%)`;
            ptx.lineWidth = Math.max(1.5, b.r*0.9);
            ptx.beginPath();
            ptx.moveTo(b.px, b.py);
            ptx.lineTo(b.x, b.y);
            ptx.stroke();
          }
        }
      }
    }

    draw(dtFull);
    requestAnimationFrame(step);
  }

  // ========= Render (main canvas) =========
  function draw(){
    // Hintergrund
    ctx.clearRect(0,0,W,H);
    const g = ctx.createRadialGradient(CX, CY, Math.min(W,H)*0.1, CX, CY, Math.min(W,H)*0.6);
    g.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--bg'));
    g.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--bg2'));
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // Zentrum
    ctx.beginPath(); ctx.arc(CX, CY, Math.max(2, 2.5*dpr), 0, Math.PI*2);
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.fill();

    // Ringe
    for (let i=0;i<rings.length;i++){
      const ring=rings[i]; if (ring.removed) continue;
      const hue = 200 + i*9;
      const colorMain = `hsla(${hue}, 65%, 66%, 0.85)`;
      const colorShine= `hsla(${hue}, 85%, 85%, 0.25)`;
      const tInner = ring.innerCirc, tOuter = ring.outerCirc;
      const thickness = (tOuter - tInner);

      ctx.save();
      ctx.lineCap='butt';

      if (ring.nSides<=0){
        // Kreisring mit Öffnung (Winkel)
        const midR = ring.midCirc;
        ctx.lineWidth = thickness;
        const gapHalf = ring.openWidthAngle*0.5;
        const start = ring.openCenter + gapHalf;
        const end = ring.openCenter - gapHalf + Math.PI*2;

        ctx.strokeStyle=colorMain;
        ctx.beginPath(); ctx.arc(CX, CY, midR, start, end, false); ctx.stroke();

        ctx.strokeStyle=colorShine;
        ctx.lineWidth = Math.max(1, thickness*0.10);
        ctx.beginPath(); ctx.arc(CX, CY, midR - thickness*0.33, start, end, false); ctx.stroke();
      } else {
        // Polygon-Ring (Material identisch, Öffnung: Sektor wie beim Kreis – wird per "destination-out" herausgestanzt)
        const n = ring.nSides, rot=ring.polyRot;
        const sector = Math.PI*2/n;

        function strokePolygonEdges(R, lw, strokeStyle){
          ctx.strokeStyle = strokeStyle;
          ctx.lineWidth = lw;
          for (let k=0;k<n;k++){
            const a1 = rot + k*sector;
            const a2 = rot + (k+1)*sector;
            const x1 = CX + Math.cos(a1)*R, y1 = CY + Math.sin(a1)*R;
            const x2 = CX + Math.cos(a2)*R, y2 = CY + Math.sin(a2)*R;
            ctx.beginPath();
            ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
            ctx.stroke();
          }
        }

        // Zuerst komplett zeichnen
        strokePolygonEdges(tOuter, 2, colorMain);
        strokePolygonEdges(tInner, 2, colorMain);
        strokePolygonEdges((tInner+tOuter)/2, 1.5, colorShine);

        // Dann Öffnungs-Sektor ausstanzen (identisch zum Kreis)
        const Rmax = tOuter + 12*dpr;
        const gapHalf = ring.openWidthAngle*0.5;
        const start = ring.openCenter - gapHalf;
        const end   = ring.openCenter + gapHalf;

        ctx.globalCompositeOperation='destination-out';
        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.arc(CX, CY, Rmax, start, end, false);
        ctx.closePath();
        ctx.fill();
        ctx.globalCompositeOperation='source-over';
      }
      ctx.restore();
    }

    // Spuren (nur im Normalmodus temporär)
    for (const b of balls){
      if (!ui.drawMode.checked && b.trail.length>1){
        ctx.save();
        ctx.globalAlpha=0.9;
        ctx.lineJoin='round'; ctx.lineCap='round';
        for (let pass=0; pass<3; pass++){
          const alpha=(0.35 - pass*0.1); if (alpha<=0) continue;
          ctx.strokeStyle=`rgba(169,184,255,${alpha})`;
          ctx.lineWidth=Math.max(1, (b.r*(0.9 - pass*0.25)));
          ctx.beginPath();
          for (let i=0;i<b.trail.length;i++){
            const p=b.trail[i];
            if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();
        }
        ctx.restore();
      }
      // Ball
      ctx.save();
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle='#fff'; ctx.fill();
      ctx.lineWidth=Math.max(1,1.5*dpr); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke();
      ctx.restore();
    }

    // Zielhilfe
    if (aiming && !launched){
      const ax=aimX-CX, ay=aimY-CY;
      const len=Math.hypot(ax,ay);
      const maxPull=Math.min(W,H)*0.46*0.55;
      const pull=Math.min(len, maxPull);
      const dirx=ax/(len||1), diry=ay/(len||1);
      const tipX=CX+dirx*pull, tipY=CY+diry*pull;

      ctx.save();
      ctx.globalAlpha=0.9;
      const accent=getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.strokeStyle=accent;
      ctx.lineWidth=Math.max(1,2*dpr);
      ctx.beginPath(); ctx.moveTo(CX, CY); ctx.lineTo(tipX, tipY); ctx.stroke();
      ctx.beginPath();
      const side=10*dpr, nx=-diry, ny=dirx;
      ctx.moveTo(tipX,tipY);
      ctx.lineTo(tipX - dirx*14*dpr + nx*side, tipY - diry*14*dpr + ny*side);
      ctx.lineTo(tipX - dirx*14*dpr - nx*side, tipY - diry*14*dpr - ny*side);
      ctx.closePath(); ctx.fillStyle=accent; ctx.fill();
      ctx.restore();
    }
  }

  // ========= Start / Menu =========
  async function startGame(){
    resize();
    computeLevel();
    hud.classList.remove('hidden');
    startScreen.classList.add('hidden');
    // Vollbild
    const el = document.documentElement;
    try{
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    }catch(e){}
    initAudio();
  }
  ui.startBtn.addEventListener('click', startGame);

  btnBack.addEventListener('click', async ()=>{
    // zurück ins Menü + vollständiges Reset (nichts läuft weiter)
    hud.classList.add('hidden');
    startScreen.classList.remove('hidden');
    resetToMenuState();
    // Fullscreen verlassen
    try{
      if (document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitFullscreenElement && document.webkitExitFullscreen) document.webkitExitFullscreen();
    }catch(e){}
  });

  // ========= Init =========
  resize();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
